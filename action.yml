name: 'Release'
description: 'generate new version, upload to s3, push tags and send to gitops'
inputs:
  aws-account:
    description: 'AWS account (dist) to upload released artifacts to. Optional if there are no artifacts, just git tag'
    required: false
  aws-region:
    description: 'AWS region'
    required: false
  aws-role:
    description: AWS role to assume for release
    required: false
  aws-codeartifact-domain:
    description: 'CodeArtifact domain name'
    required: true
  aws-codeartifact-repository:
    description: 'CodeArtifact repository name'
    required: true
  aws-codeartifact-maven:
    description: 'If true, then publish maven artifacts to AWS CodeArtifact'
    required: false
  aws-ecr:
    description: 'If true, then push docker image to ECR'
    required: false
  aws-s3-bucket:
    description: 'S3 bucket to upload released artifacts to'
    required: false
  aws-s3-dir:
    description: 'S3 bucket directory to upload released artifacts to, by default = current repo name'
    required: false
  node-version:
    description: 'Node.js version to use to publish npm packages, default is 22 (pre-cached in Ubuntu 24)'
    required: false
    default: '22'
  npmjs-token:
    description: 'token to publish npm package in npmjs'
    required: false
  tag-context:
    description: |
      Context for tag generation: 'repo' (default) or 'branch'
      Use 'branch' to release from non-main long-living branches such as v1-support (given v2 is in main)
      When 'branch' is, make sure to use actions/checkout with 'fetch-depth: 0'
    required: false
    default: 'repo'
  version-update-script:
    description: 'sh script that allows to update version in custom file(s), not just pom.xml or package.json'
    required: false
#  dev-release:
#    description: 'Used to make dev release - no release tagging, just upload binaries - works only for s3 (not for CodeArtifact), may be for ECR'
#    required: false
#    default: 'false'

runs:
  using: "composite"
  steps:

## Phase 0 - Init: validate inputs, infer defaults, login in AWS

    - name: Init
      id: init
      shell: bash
      run: |
        # this action is called in context of the microservice repo, so GITHUB_REPOSITORY has a format of 'company/service'
        service=$(echo "${GITHUB_REPOSITORY}" | awk -F'/' '{print $2}')
        echo "service=$service" >> $GITHUB_OUTPUT
        
        if [ -d s3 ]; then
          echo "aws_s3=true" >> $GITHUB_OUTPUT
          aws_s3_dir="${{ inputs.aws-s3-dir }}"; [ -z "$aws_s3_dir" ] && aws_s3_dir="$service"
          echo "aws_s3_dir=$aws_s3_dir" >> $GITHUB_OUTPUT
        fi
        
        if [ -d s3 ] || [ "${{ inputs.aws-ecr }}" = "true" ] || [ "${{ inputs.aws-codeartifact-maven }}" = "true" ]; then
          if [ -z "${{ inputs.aws-account }}" ] || [ -z "${{ inputs.aws-region }}" ] || [ -z "${{ inputs.aws-role }}" ]; then
            echo "Error: aws-account, aws-region, and aws-role must all be provided" >&2
            exit 1
          fi
        fi

        if [ "${{ inputs.aws-codeartifact-maven }}" = "true" ]; then
          if [ -z "${{ inputs.aws-codeartifact-domain }}" ] || [ -z "${{ inputs.aws-codeartifact-repository }}" ]; then
            echo "Error: aws-codeartifact-domain and aws-codeartifact-repository must be provided when aws-codeartifact-maven is true" >&2
            exit 1
          fi
        fi
        
        if [ -d s3 ] && [ -z "${{ inputs.aws-s3-bucket }}" ] ; then
          echo "Error: aws-s3-bucket must be provided when using S3" >&2
          exit 1
        fi

    - name: Login AWS
      if: steps.init.outputs.aws_s3 || inputs.aws-ecr || inputs.aws-codeartifact-maven
      id: login-aws
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-region: ${{ inputs.aws-region }}
        role-to-assume: arn:aws:iam::${{ inputs.aws-account }}:role/${{ inputs.aws-role }}
        output-credentials: true
#
    - name: Login to Amazon ECR
      if: inputs.aws-ecr
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2 # outputs.registry = {acc_id}.dkr.ecr.us-east-1.amazonaws.com

## Phase 1 - Generate a new version

    - name: Generate new version
      id: generate_version
      uses: anothrNick/github-tag-action@v1 # https://github.com/anothrNick/github-tag-action?tab=readme-ov-file
      env:
        TAG_CONTEXT: ${{ inputs.tag-context }} # given branches main v2.x.y and legacy v1.x.y - generate next version based on current branch
        DRY_RUN: true # just generate a new version, do not push tag

    - name: Finalize version
      id: version
      shell: bash
      run: |
        version="${{ steps.generate_version.outputs.new_tag }}"
        patch=$version
        major="$(echo "$version" | awk -F. '{print $1}')"
        minor="$(echo "$version" | awk -F. '{print $1"."$2}')"
        
        echo "version=$version" >> $GITHUB_OUTPUT
        echo "tags=$patch $minor $major latest" >> $GITHUB_OUTPUT
#        echo "patch=$patch" >> $GITHUB_OUTPUT
#        echo "major=$major" >> $GITHUB_OUTPUT
#        echo "minor=$minor" >> $GITHUB_OUTPUT

## Phase 2 - Update version in code

    - name: Setup Java
      if: inputs.aws-codeartifact-maven
      uses: agilecustoms/setup-java-codeartifact@main
      with:
        aws-account: ${{ inputs.aws-account }}
        aws-region: ${{ inputs.aws-region }}
        aws-role: ${{ inputs.aws-role }}
        aws-codeartifact-domain: ${{ inputs.aws-codeartifact-domain }}
        aws-codeartifact-repository: ${{ inputs.aws-codeartifact-repository }}
        aws-login: false # we already logged in AWS in a previous step
        cache: maven
        java-distribution: 'temurin' # use temurin as it is available by default in GitHub Actions runners

    - name: Update version in maven
      if: inputs.aws-codeartifact-maven
      shell: bash
      run: mvn --no-transfer-progress versions:set -DnewVersion=${{ steps.version.outputs.version }} -DoldVersion=\* -DgroupId=\* -DartifactId=\*

    - name: Setup Node
      if: inputs.npmjs-token
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}
        registry-url: 'https://registry.npmjs.org'

    - name: Update version in npm
      if: inputs.npmjs-token
      shell: bash
      run: npm version ${{ steps.version.outputs.version }} --no-git-tag-version

    - name: Custom version update script
      if: inputs.version-update-script
      shell: bash
      run: new_version=${{ steps.version.outputs.version }} && ${{ inputs.version-update-script }}

## Phase 3 - Publish artifacts

    - name: Upload in S3
      if: steps.init.outputs.aws_s3
      uses: agilecustoms/release-s3@main
      with:
        access-key-id: ${{ steps.login-aws.outputs.aws-access-key-id }}
        secret-access-key: ${{ steps.login-aws.outputs.aws-secret-access-key }}
        session-token: ${{ steps.login-aws.outputs.aws-session-token }}
        bucket: ${{ inputs.aws-s3-bucket }}
        bucket-dir: ${{ steps.init.outputs.aws_s3_dir }}
        versions: ${{ steps.version.outputs.tags }}
#        tags: Release=${{ inputs.dev-release == 'false' && 'true' || 'false' }}

    - name: Push Docker image in ECR
      if: inputs.aws-ecr
      shell: bash
      run: |
        service="${{ steps.init.outputs.service }}"
        ECR_IMAGE=${{ steps.login-ecr.outputs.registry }}/$service
        tags=$(echo "${{ steps.version.outputs.tags }}" | sed 's/[^ ]\+/imageTag=&/g')
        AWS_PAGER="" aws ecr batch-delete-image --repository-name $service --image-ids $tags || true
        tags="${{ steps.version.outputs.tags }}"
        for tag in $tags; do
          docker tag $service $ECR_IMAGE:$tag
        done
        docker push --all-tags $ECR_IMAGE

    # maven.main.skip=true (from Maven 3.9.0) to skip main sources compilation
    # maven.test.skip=true skips tests compilation and running (-DskipTests just skips running)
    # it does repackage though! (this is for good, bcz pom versions changed)
    # TODO: verify phase still run in build and release jobs
    # TODO: checkstyle and enforcer still run in both jobs
    - name: Upload to CodeArtifact
      if: inputs.aws-codeartifact-maven
      shell: bash
      run: |
        set +e
        output=$(mvn --no-transfer-progress deploy -Dmaven.main.skip=true -Dmaven.test.skip=true 2>&1)
        error_code=$?
        echo "$output"
        if [ $error_code -ne 0 ] && [ "${{ github.run_attempt }}" != "1" ]; then
          if echo "$output" | grep -q "status code: 409"; then
            echo "Ignore error 'version already exist' for run attempt ${{ github.run_attempt }}"
            exit 0
          fi
        fi
        exit $error_code

    # get namespace from package.json: "name": "@company/envctl", then find mapping namespace => npm repo in .npmrc file
    # since there is no .npmrc file, do publish in npmjs.com npm registry
    - name: Publish in npmjs
      if: inputs.npmjs-token
      shell: bash
      run: |
        set +e
        output=$(npm publish --access public 2>&1)
        error_code=$?
        echo "$output"
        if [ $error_code -ne 0 ] && [ "${{ github.run_attempt }}" != "1" ]; then
          if echo "$output" | grep -q "You cannot publish over the previously published versions"; then
            echo "Ignore error 'version already exist' for run attempt ${{ github.run_attempt }}"
            exit 0
          fi
        fi
        exit $error_code
      env:
        NODE_AUTH_TOKEN: ${{ inputs.npmjs-token }}

## Phase 4 - Git push

#    - name: Error to test publish idempotency
#      shell: bash
#      run: |
#        echo "intentional error" >&2
#        exit 1

    - name: Git push
      id: git
      #      if: inputs.dev-release == 'false'
      shell: bash
      run: |
        git config --global user.name "CI User"
        git config --global user.email "user@ci.com"
        
        # fix any permission issues from earlier steps (npm version can create files with root permissions)
        sudo chown -R "$(id -un):$(id -gn)" .
        
        # stage files that might be modified/deleted by previous steps; check if there are any changes and commit
        git add -u
        if ! git diff --cached --quiet; then
          git commit -m "Release version ${{ steps.version.outputs.version }} [skip ci]"
          echo "changes_detected=true" >> $GITHUB_OUTPUT
        else
          echo "No changes to commit."
        fi
        
        git tag -d ${{ steps.version.outputs.tags }} 2>/dev/null || true
        
        tags="${{ steps.version.outputs.tags }}"
        for tag in $tags; do
          git tag "$tag"
        done
        
        # turn "1 1.0 1.0.0 latest" into "refs/tags/1 refs/tags/1.0 refs/tags/1.0.0 refs/tags/latest"
        refs=$(echo "${{ steps.version.outputs.tags }}" |  sed 's/[^ ]\+/refs\/tags\/&/g')
        # push changes made in 'main' along with tags (latest and patch_tag) atomically. use --force to overwrite old tags
        git push --atomic origin main $refs --force

outputs:
  changes-detected:
    description: "Whether there were any changes detected in the repository"
    value: ${{ steps.git.outputs.changes_detected }}
  version:
    description: "Newly released version"
    value: ${{ steps.version.outputs.version }}
