name: 'Release'
description: 'generate new version, upload to s3, push tags and send to gitops'
inputs:
  aws-account:
    description: 'AWS account to publish artifacts to. Not needed if there are no artifacts, just git tag'
    required: false
  aws-region:
    description: 'AWS region'
    required: false
  aws-role:
    description: 'IAM role to assume to publish, ex. `/ci/publisher`'
    required: false
  aws-codeartifact-domain:
    description: 'CodeArtifact domain name, ex. `mycompany`'
    required: false
  aws-codeartifact-repository:
    description: 'CodeArtifact repository name, ex. `maven`'
    required: false
  aws-codeartifact-maven:
    description: 'If true, then publish maven artifacts to AWS CodeArtifact'
    required: false
  aws-ecr:
    description: 'If true, then push docker image to ECR'
    required: false
  aws-s3-bucket:
    description: 'Required if uploading to S3 (i.e. s3/ directory exists)'
    required: false
  aws-s3-dir:
    description: 'Allows specifying S3 bucket directory to upload artifacts to. By default just place in `bucket/{repo-name}/{version}/*`'
    required: false
  dev-release:
    description: 'Allows to create temporary named release, mainly for dev testing. Implementation is different for all supported artifact types'
    required: false
    default: 'false'
  dev-branch-prefix:
    description: 'Allows to enforce branch prefix for dev-releases, this help to write auto-disposal rules. Empty string disables enforcement'
    required: false
    default: 'dev/'
  floating-tags:
    description: 'When next version to be released is 1.2.4, then also release 1, 1.2 and latest. Not desired for public terraform modules'
    required: false
    default: 'true'
  node-version:
    description: 'Node.js version to publish npm packages, default is 22 (pre-cached in Ubuntu 24)'
    required: false
    default: '22'
  tag-context:
    description: 'Context for tag generation: `repo` (default) or `branch`. Use `branch` to release from non-main long-living branches'
    required: false
    default: 'repo'
  version:
    description: 'Explicit version to use instead of auto-generating. When provided, only this single version/tag will be created (no latest, major, minor tags)'
    required: false
  version-prefix:
    description: 'Optional prefix for version, ex. `v` to generate `v1.0.0` instead of `1.0.0`. Used only when version is auto-generated'
    required: false
  version-update-script:
    description: 'sh script that allows to update version in custom file(s), not only files governed by build tool (pom.xml, package.json, etc)'
    required: false

runs:
  using: "composite"
  steps:

## Phase 1 - Init: validate inputs, infer defaults, login in AWS

    - name: Validate npmjs token
      if: env.NODE_AUTH_TOKEN && inputs.dev-release == 'true'
      shell: bash
      run: |
        echo "Error: npmjs does not support dev-release (version inferred from branch name), npmjs only supports semver" >&2; exit 1

    - name: Validate version
      if: inputs.version && inputs.dev-release == 'true'
      shell: bash
      run: |
        echo "Error: explicit version cannot be used with dev-release=true" >&2; exit 1

    - name: Init
      id: init
      shell: bash
      run: |
        # GITHUB_REPOSITORY has a format of 'company/service'
        service=$(echo "${GITHUB_REPOSITORY}" | awk -F'/' '{print $2}')
        echo "service=$service" >> $GITHUB_OUTPUT
        
        if [ "${{ inputs.dev-release }}" = "true" ] && [ -n "${{ inputs.dev-branch-prefix }}" ]; then
          branch="${GITHUB_REF#refs/heads/}"
          if [[ "$branch" != "${{ inputs.dev-branch-prefix }}"* ]]; then
            echo "Error: current branch '$branch' must start with '${{ inputs.dev-branch-prefix }}' when dev-release is true" >&2
            exit 1
          fi
        fi
        
        if [ -d s3 ]; then
          echo "aws_s3=true" >> $GITHUB_OUTPUT
        fi
        
        if [ -d s3 ] || [ "${{ inputs.aws-ecr }}" = "true" ] || [ "${{ inputs.aws-codeartifact-maven }}" = "true" ]; then
          if [ -z "${{ inputs.aws-account }}" ] || [ -z "${{ inputs.aws-region }}" ] || [ -z "${{ inputs.aws-role }}" ]; then
            echo "Error: aws-account, aws-region, and aws-role must all be provided" >&2
            exit 1
          fi
        fi

        if [ "${{ inputs.aws-codeartifact-maven }}" = "true" ]; then
          if [ -z "${{ inputs.aws-codeartifact-domain }}" ] || [ -z "${{ inputs.aws-codeartifact-repository }}" ]; then
            echo "Error: aws-codeartifact-domain and aws-codeartifact-repository must be provided when aws-codeartifact-maven is true" >&2
            exit 1
          fi
        fi
        
        if [ -d s3 ] && [ -z "${{ inputs.aws-s3-bucket }}" ] ; then
          echo "Error: aws-s3-bucket must be provided when using S3" >&2
          exit 1
        fi

    - name: Login AWS
      if: steps.init.outputs.aws_s3 || inputs.aws-ecr || inputs.aws-codeartifact-maven
      id: login-aws
      uses: aws-actions/configure-aws-credentials@v4.2.1 # v4 doesn't point to latest version
      with:
        aws-region: ${{ inputs.aws-region }}
        role-to-assume: arn:aws:iam::${{ inputs.aws-account }}:role/${{ inputs.aws-role }}
        output-credentials: true

    - name: Login to Amazon ECR
      if: inputs.aws-ecr
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2 # outputs.registry = {acc_id}.dkr.ecr.us-east-1.amazonaws.com

## Phase 2 - Generate a new version

    - name: Generate new version
      if: inputs.dev-release == 'false' && !inputs.version
      id: generate_version
      uses: anothrNick/github-tag-action@v1 # https://github.com/anothrNick/github-tag-action?tab=readme-ov-file
      env:
        DRY_RUN: true # just generate a new version, do not push tag
        TAG_CONTEXT: ${{ inputs.tag-context }} # given branches main v2.x.y and legacy v1.x.y - generate next version based on current branch
        TAG_PREFIX: ${{ inputs.version-prefix }}

    - name: Finalize version
      id: version
      shell: bash
      run: |
        if [ "${{ inputs.dev-release }}" = "true" ]; then
          version="$(echo "${GITHUB_REF#refs/heads/}" | tr '/' '-')" # refs/heads/feature/abc -> feature-abc
          tags="$version"
        elif [ -n "${{ inputs.version }}" ]; then
          version="${{ inputs.version }}"
          tags="$version"
        else
          version="${{ steps.generate_version.outputs.new_tag }}"
          tags="$version"
          if [ "${{ inputs.floating-tags }}" = "true" ]; then
            patch="$version"
            major="$(echo "$version" | awk -F. '{print $1}')"
            minor="$(echo "$version" | awk -F. '{print $1"."$2}')"
            tags="$patch $minor $major latest"
          fi
        fi
        
        echo "version=$version" >> $GITHUB_OUTPUT
        echo "tags=$tags" >> $GITHUB_OUTPUT

## Phase 3 - Prepare (update versions, edit files)

    - name: Setup Java
      if: inputs.aws-codeartifact-maven
      uses: agilecustoms/setup-maven-codeartifact@v1
      with:
        aws-account: ${{ inputs.aws-account }}
        aws-region: ${{ inputs.aws-region }}
        aws-role: ${{ inputs.aws-role }}
        aws-codeartifact-domain: ${{ inputs.aws-codeartifact-domain }}
        aws-codeartifact-repository: ${{ inputs.aws-codeartifact-repository }}
        aws-login: false # we already logged in AWS in a previous step

    - name: Update version in maven
      if: inputs.aws-codeartifact-maven
      shell: bash
      run: mvn --no-transfer-progress versions:set -DnewVersion=${{ steps.version.outputs.version }} -DoldVersion=* -DgroupId=* -DartifactId=*

    - name: Setup Node
      if: env.NODE_AUTH_TOKEN
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}
        registry-url: 'https://registry.npmjs.org'

    - name: Update version in npm
      if: env.NODE_AUTH_TOKEN
      shell: bash
      run: npm version ${{ steps.version.outputs.version }} --no-git-tag-version

    - name: Custom version update script
      if: inputs.version-update-script
      shell: bash
      run: new_version=${{ steps.version.outputs.version }} && ${{ inputs.version-update-script }}

## Phase 4 - Publish artifacts

    - name: Upload in S3
      if: steps.init.outputs.aws_s3
      uses: agilecustoms/publish-s3@main
      with:
        access-key-id: ${{ steps.login-aws.outputs.aws-access-key-id }}
        secret-access-key: ${{ steps.login-aws.outputs.aws-secret-access-key }}
        session-token: ${{ steps.login-aws.outputs.aws-session-token }}
        bucket: ${{ inputs.aws-s3-bucket }}
        bucket-dir: ${{ inputs.aws-s3-dir }}
        versions: ${{ steps.version.outputs.tags }}
        dev-release: ${{ inputs.dev-release }}

    - name: Push Docker image in ECR
      if: inputs.aws-ecr
      shell: bash
      run: |
        service="${{ steps.init.outputs.service }}"
        ECR_IMAGE=${{ steps.login-ecr.outputs.registry }}/$service
        tags=$(echo "${{ steps.version.outputs.tags }}" | sed 's/[^ ]\+/imageTag=&/g')
        AWS_PAGER="" aws ecr batch-delete-image --repository-name $service --image-ids $tags || true
        tags="${{ steps.version.outputs.tags }}"
        for tag in $tags; do
          docker tag $service $ECR_IMAGE:$tag
        done
        docker push --all-tags $ECR_IMAGE

    # maven.main.skip=true (from Maven 3.9.0) to skip main sources compilation
    # maven.test.skip=true skips tests compilation and running (-DskipTests just skips running)
    # it does repackage though! (this is for good, bcz pom versions changed)
    # TODO: verify phase still run in build and release jobs
    # TODO: checkstyle and enforcer still run in both jobs
    - name: Upload to CodeArtifact
      if: inputs.aws-codeartifact-maven
      shell: bash
      run: |
        set +e
        output=$(mvn --no-transfer-progress deploy -Dmaven.main.skip=true -Dmaven.test.skip=true 2>&1)
        error_code=$?
        echo "$output"
        if [ $error_code -ne 0 ] && [ "${{ github.run_attempt }}" != "1" ]; then
          if echo "$output" | grep -q "status code: 409"; then
            echo "Ignore error 'version already exist' for run attempt ${{ github.run_attempt }}"
            exit 0
          fi
        fi
        exit $error_code

    # get namespace from package.json: "name": "@company/envctl", then find mapping namespace => npm repo in .npmrc file
    # since there is no .npmrc file, do publish in npmjs.com npm registry
    - name: Publish in npmjs
      if: env.NODE_AUTH_TOKEN
      shell: bash
      run: |
        set +e
        output=$(npm publish --access public 2>&1)
        error_code=$?
        echo "$output"
        if [ $error_code -ne 0 ] && [ "${{ github.run_attempt }}" != "1" ]; then
          if echo "$output" | grep -q "You cannot publish over the previously published versions"; then
            echo "Ignore error 'version already exist' for run attempt ${{ github.run_attempt }}"
            exit 0
          fi
        fi
        exit $error_code
      env:
        NODE_AUTH_TOKEN: ${{ env.NODE_AUTH_TOKEN }}

## Phase 5 - Git push

#    - name: Error to test publish idempotency
#      shell: bash
#      run: |
#        echo "intentional error" >&2
#        exit 1

    - name: Git push
      id: git
      if: inputs.dev-release == 'false'
      shell: bash
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
        
        # fix any permission issues from earlier steps (npm version can create files with root permissions)
        sudo chown -R "$(id -un):$(id -gn)" .
        
        # stage files that might be modified/deleted by previous steps; check if there are any changes and commit
        git add -u
        if ! git diff --cached --quiet; then
          git commit -m "Release version ${{ steps.version.outputs.version }} [skip ci]"
          echo "changes_detected=true" >> $GITHUB_OUTPUT
        else
          echo "No changes to commit."
        fi
        
        git tag -d ${{ steps.version.outputs.tags }} 2>/dev/null || true
        
        tags="${{ steps.version.outputs.tags }}"
        for tag in $tags; do
          git tag "$tag"
        done
        
        # turn "1 1.0 1.0.0 latest" into "refs/tags/1 refs/tags/1.0 refs/tags/1.0.0 refs/tags/latest"
        refs=$(echo "${{ steps.version.outputs.tags }}" |  sed 's/[^ ]\+/refs\/tags\/&/g')
        # push changes along with tags (latest and patch_tag) atomically. use --force to overwrite old tags
        git push --atomic origin ${{ github.ref_name }} $refs --force

## Phase 6 - GitHub Release

    - name: Create GitHub Release
      if: inputs.dev-release == 'false'
      shell: bash
      run: |
        gh release create ${{ steps.version.outputs.version }}

outputs:
  changes_detected:
    description: "Whether there were any changes detected in the repository"
    value: ${{ steps.git.outputs.changes_detected }}
  version:
    description: "Newly released version"
    value: ${{ steps.version.outputs.version }}
