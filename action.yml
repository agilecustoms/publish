name: 'Release'
description: 'generate new version, upload to s3, push tags and send to gitops'
inputs:
  aws-account:
    description: 'AWS account (dist) to upload released artifacts to'
    required: false
    default: ''
  dev-release:
    description: 'Used to make dev release - no release tagging, just upload binaries - works only for s3 (not for CodeArtifact), may be for ECR'
    required: false
    default: 'false'
  gh-token:
    description: |
      Powerful token that allows to call other GH actions in the organization
      Needed to push in tt-gitops, not used for dev release
    required: false
  publish:
    description: 'One of the following: npm_npmjs, npm_CodeArtifact, docker_ECR'
    required: false
    default: ''
runs:
  using: "composite"
  steps:

## Phase 0 - Init: validate inputs, infer defaults, login in AWS

    - name: Init
      id: init
      shell: bash
      # TODO: check that publish has one of the allowed values
      # convention: if 's3' directory exists, then upload to S3
      # this action is called in context of the microservice repo, so GITHUB_REPOSITORY has format of 'agilecustoms/tt-web'
      run: |        
        if [ -d s3 ]; then
          echo "upload-s3=true" >> $GITHUB_OUTPUT
          if [ -z "${{ inputs.aws-account }}" ]; then
            echo "AWS account is required to upload /dist in S3" >&2
            exit 1
          fi
        fi
        
        if [ "${{ inputs.dev-release }}" == "false" ] && [ "${{ startsWith(github.repository, 'agilecustoms/tt-') }}" == "true" ] && [ -z "${{ inputs.gh-token }}" ]; then
          echo "GH token is required to push tags (dev-release = false)" >&2
          exit 1
        fi
        
        echo "service=$(echo "${GITHUB_REPOSITORY}" | awk -F'/' '{print $2}')" >> $GITHUB_OUTPUT

    - name: Login AWS
      if: steps.init.outputs.upload-s3 || inputs.publish == 'docker_ECR' || inputs.publish == 'maven_CodeArtifact'
      id: login-aws
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-region: us-east-1
        role-to-assume: arn:aws:iam::${{ inputs.aws-account }}:role/ci/builder
        output-credentials: true

    - name: Login to Amazon ECR
      if: inputs.publish == 'docker_ECR'
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2 # outputs.registry = {acc_id}.dkr.ecr.us-east-1.amazonaws.com



## Phase 1 - Generate new version

    - name: Generate new version
      if: inputs.dev-release == 'false'
      id: version
      uses: anothrNick/github-tag-action@v1 # https://github.com/anothrNick/github-tag-action?tab=readme-ov-file
      env:
        DRY_RUN: true # just generate new version, do not push tag

    - name: Generate S3 key
      if: steps.init.outputs.upload-s3
      id: s3_key
      shell: bash
      run: |
        key="${{ steps.init.outputs.service }}/${{ steps.version.outputs.new_tag }},${{ steps.init.outputs.service }}/latest"
        if [ "${{ inputs.dev-release }}" == "true" ]; then
          key="${{ steps.init.outputs.service }}/${{ github.ref_name }}"
        fi
        echo "key=$key" >> $GITHUB_OUTPUT

## Phase 2 - Update version in code

    - name: Prepare Java
      if: inputs.publish == 'maven_CodeArtifact'
      uses: agilecustoms/gha-prepare-java@main
      with:
        AWS_ACCOUNT: ${{ inputs.aws-account }}
        role-name: builder

    - name: Update version in maven
      if: inputs.publish == 'maven_CodeArtifact'
      shell: bash
      run: mvn --no-transfer-progress versions:set -DnewVersion=${{ steps.version.outputs.new_tag }} -DoldVersion=\* -DgroupId=\* -DartifactId=\*

## Phase 3 - Git push

    - name: Git push
      if: inputs.dev-release == 'false'
      shell: bash
      run: |
        git config --global user.name "CI User" && git config --global user.email "user@ci.com"
        git add -u && git commit -m "Release version ${{ steps.version.outputs.new_tag }} [skip ci]" 2>/dev/null || true
        git tag -d latest 2>/dev/null || true
        git tag latest
        git tag ${{ steps.version.outputs.new_tag }}
        git push --atomic origin main refs/tags/latest refs/tags/${{ steps.version.outputs.new_tag }} --force
      # use 2>/dev/null || true to ignore error if there is nothing to commit or no 'latest' tag to delete
      # push changes made in 'main' along with tags (latest and new_tag) atomically. use --force to overwrite 'latest' tag

## Phase 4 - Publish artifacts

    - name: Upload S3
      if: steps.init.outputs.upload-s3
      uses: agilecustoms/gha-upload-s3@main
      with:
        access-key-id: ${{ steps.login-aws.outputs.aws-access-key-id }}
        secret-access-key: ${{ steps.login-aws.outputs.aws-secret-access-key }}
        session-token: ${{ steps.login-aws.outputs.aws-session-token }}
        source-dir: 'dist' # after 'download-artifact' step, there are assets in 'dist/*'
        bucket: 'agilecustoms-dist'
        bucket-dir: ${{ steps.s3_key.outputs.key }}
        tags: Release=${{ inputs.dev-release == 'false' && 'true' || 'false' }}

    - name: Push Docker image in ECR
      if: inputs.publish == 'docker_ECR'
      shell: bash
      run: |
        service="${{ steps.init.outputs.service }}"
        AWS_PAGER="" aws ecr batch-delete-image --repository-name $service --image-ids imageTag=latest
        ECR_IMAGE=${{ steps.login-ecr.outputs.registry }}/$service
        docker tag $service $ECR_IMAGE:${{ steps.version.outputs.new_tag }}
        docker tag $service $ECR_IMAGE:latest
        docker push --all-tags $ECR_IMAGE

    - name: Upload to CodeArtifact
      if: inputs.publish == 'maven_CodeArtifact'
      shell: bash
      run: mvn --no-transfer-progress deploy -Dmaven.main.skip=true -Dmaven.test.skip=true

## Phase 5 - Send to gitops

    # I can not use placeholders in 'uses' section, so workaround is to have a step per project: tt (TimeTravel), rc (RapidCBP), etc.
    # TODO: improve this condition to remove hardcode and then add check that gh-token is present
    - name: Send to tt-gitops
      if: inputs.dev-release == 'false' && startsWith(github.repository, 'agilecustoms/tt-')
      uses: agilecustoms/tt-gitops@main
      with:
        service: ${{ steps.init.outputs.service }}
        version: ${{ steps.version.outputs.new_tag }}
        token: ${{ inputs.gh-token }}

outputs:
  version:
    description: "Newly released version"
    value: ${{ steps.version.outputs.new_tag }}
